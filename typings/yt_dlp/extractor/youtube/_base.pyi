import enum
from ...networking.exceptions import HTTPError as HTTPError, network_exceptions as network_exceptions
from ...utils import ExtractorError as ExtractorError, bug_reports_message as bug_reports_message, datetime_from_str as datetime_from_str, filter_dict as filter_dict, get_first as get_first, int_or_none as int_or_none, is_html as is_html, join_nonempty as join_nonempty, parse_count as parse_count, qualities as qualities, str_to_int as str_to_int, traverse_obj as traverse_obj, try_call as try_call, try_get as try_get, unified_timestamp as unified_timestamp, url_or_none as url_or_none, variadic as variadic
from ..common import InfoExtractor as InfoExtractor
from _typeshed import Incomplete

class _PoTokenContext(enum.Enum):
    PLAYER = 'player'
    GVS = 'gvs'
    SUBS = 'subs'

INNERTUBE_CLIENTS: Incomplete

def short_client_name(client_name): ...
def build_innertube_clients() -> None: ...

class BadgeType(enum.Enum):
    AVAILABILITY_UNLISTED = ...
    AVAILABILITY_PRIVATE = ...
    AVAILABILITY_PUBLIC = ...
    AVAILABILITY_PREMIUM = ...
    AVAILABILITY_SUBSCRIPTION = ...
    LIVE_NOW = ...
    VERIFIED = ...

CONFIGURATION_ARG_KEY: str

class YoutubeBaseInfoExtractor(InfoExtractor):
    def ucid_or_none(self, ucid): ...
    def handle_or_none(self, handle): ...
    def handle_from_url(self, url): ...
    def ucid_from_url(self, url): ...
    @property
    def is_authenticated(self): ...
    def extract_yt_initial_data(self, item_id, webpage, fatal: bool = True): ...
    def extract_ytcfg(self, video_id, webpage): ...
    def generate_api_headers(self, *, ytcfg=None, delegated_session_id=None, user_session_id=None, session_index=None, visitor_data=None, api_hostname=None, default_client: str = 'web', **kwargs): ...
    @staticmethod
    def extract_relative_time(relative_time_text): ...
    @staticmethod
    def is_music_url(url): ...

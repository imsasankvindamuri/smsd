import abc
import enum
import io
import types
import typing
from ..compat.types import NoneType as NoneType
from ..cookies import YoutubeDLCookieJar as YoutubeDLCookieJar
from ..utils import bug_reports_message as bug_reports_message, classproperty as classproperty, deprecation_warning as deprecation_warning, error_to_str as error_to_str, update_url_query as update_url_query
from ..utils.networking import HTTPHeaderDict as HTTPHeaderDict, normalize_url as normalize_url
from ._helper import make_ssl_context as make_ssl_context, wrap_request_errors as wrap_request_errors
from .exceptions import NoSupportingHandlers as NoSupportingHandlers, RequestError as RequestError, TransportError as TransportError, UnsupportedRequest as UnsupportedRequest
from _typeshed import Incomplete
from collections.abc import Iterable, Mapping

DEFAULT_TIMEOUT: int

def register_preference(*handlers: type[RequestHandler]): ...

class RequestDirector:
    handlers: dict[str, RequestHandler]
    preferences: set[Preference]
    logger: Incomplete
    verbose: Incomplete
    def __init__(self, logger, verbose: bool = False) -> None: ...
    def close(self) -> None: ...
    def add_handler(self, handler: RequestHandler): ...
    def send(self, request: Request) -> Response: ...

def register_rh(handler): ...

class Features(enum.Enum):
    ALL_PROXY = ...
    NO_PROXY = ...

class RequestHandler(abc.ABC, metaclass=abc.ABCMeta):
    headers: Incomplete
    cookiejar: Incomplete
    timeout: Incomplete
    proxies: Incomplete
    source_address: Incomplete
    verbose: Incomplete
    prefer_system_certs: Incomplete
    verify: Incomplete
    legacy_ssl_support: Incomplete
    def __init__(self, *, logger, headers: HTTPHeaderDict = None, cookiejar: YoutubeDLCookieJar = None, timeout: float | int | None = None, proxies: dict | None = None, source_address: str | None = None, verbose: bool = False, prefer_system_certs: bool = False, client_cert: dict[str, str | None] | None = None, verify: bool = True, legacy_ssl_support: bool = False, **_) -> None: ...
    @wrap_request_errors
    def validate(self, request: Request): ...
    @wrap_request_errors
    def send(self, request: Request) -> Response: ...
    def close(self) -> None: ...
    @classproperty
    def RH_NAME(cls): ...
    @classproperty
    def RH_KEY(cls): ...
    def __enter__(self): ...
    def __exit__(self, *args) -> None: ...

class Request:
    proxies: Incomplete
    extensions: Incomplete
    def __init__(self, url: str, data: RequestData = None, headers: typing.Mapping | None = None, proxies: dict | None = None, query: dict | None = None, method: str | None = None, extensions: dict | None = None) -> None: ...
    @property
    def url(self): ...
    @url.setter
    def url(self, url) -> None: ...
    @property
    def method(self): ...
    @method.setter
    def method(self, method) -> None: ...
    @property
    def data(self): ...
    @data.setter
    def data(self, data: RequestData): ...
    @property
    def headers(self) -> HTTPHeaderDict: ...
    @headers.setter
    def headers(self, new_headers: Mapping): ...
    def update(self, url=None, data=None, headers=None, query=None, extensions=None) -> None: ...
    def copy(self): ...

HEADRequest: Incomplete
PATCHRequest: Incomplete
PUTRequest: Incomplete

class Response(io.IOBase):
    fp: Incomplete
    headers: Incomplete
    status: Incomplete
    url: Incomplete
    reason: Incomplete
    extensions: Incomplete
    def __init__(self, fp: io.IOBase, url: str, headers: Mapping[str, str], status: int = 200, reason: str | None = None, extensions: dict | None = None) -> None: ...
    def readable(self): ...
    def read(self, amt: int | None = None) -> bytes: ...
    def close(self): ...
    def get_header(self, name, default=None): ...
    @property
    def code(self): ...
    def getcode(self): ...
    def geturl(self): ...
    def info(self): ...
    def getheader(self, name, default=None): ...
RequestData = bytes | Iterable[bytes] | typing.IO | None
Preference = typing.Callable[[RequestHandler, Request], int]

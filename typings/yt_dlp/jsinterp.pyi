import collections
from .utils import ExtractorError as ExtractorError, NO_DEFAULT as NO_DEFAULT, function_with_repr as function_with_repr, js_to_json as js_to_json, remove_quotes as remove_quotes, truncate_string as truncate_string, unified_timestamp as unified_timestamp, write_string as write_string
from _typeshed import Incomplete

def js_number_to_string(val: float, radix: int = 10): ...

class JS_Undefined: ...

class JS_Break(ExtractorError):
    def __init__(self) -> None: ...

class JS_Continue(ExtractorError):
    def __init__(self) -> None: ...

class JS_Throw(ExtractorError):
    error: Incomplete
    def __init__(self, e) -> None: ...

class LocalNameSpace(collections.ChainMap):
    def __setitem__(self, key, value) -> None: ...
    def __delitem__(self, key) -> None: ...

class Debugger:
    ENABLED: Incomplete
    @staticmethod
    def write(*args, level: int = 100) -> None: ...
    @classmethod
    def wrap_interpreter(cls, f): ...

class JSInterpreter:
    def __init__(self, code, objects=None) -> None: ...
    class Exception(ExtractorError):
        def __init__(self, msg, expr=None, *args, **kwargs) -> None: ...
    @Debugger.wrap_interpreter
    def interpret_statement(self, stmt, local_vars, allow_recursion: int = 100): ...
    def interpret_expression(self, expr, local_vars, allow_recursion): ...
    def extract_object(self, objname, *global_stack): ...
    def extract_function_code(self, funcname): ...
    def extract_function(self, funcname, *global_stack): ...
    def extract_function_from_code(self, argnames, code, *global_stack): ...
    def call_function(self, funcname, *args): ...
    def build_function(self, argnames, code, *global_stack): ...
